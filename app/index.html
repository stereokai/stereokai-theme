<!DOCTYPE html>
<html lang="en" class="-no-js">

<head>
  <title>Stereokai.com</title>
  <meta charset="utf-8">

  <!-- META -->
  <meta name="description" content="">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=no">
  <!-- END META -->

  <script>
    (function(H){
      H.className = '-js';
      // Opera 8.0+ (UA detection to detect Blink/v8-powered Opera)
      window.isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
      isOpera && H.classList.add('opera');
      // Firefox 1.0+
      window.isFirefox = typeof InstallTrigger !== 'undefined';
      isFirefox && H.classList.add('ff');
      // At least Safari 3+: "[object HTMLElementConstructor]"
      window.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
      isSafari && H.classList.add('safari');
      // At least IE6
      window.isIE = !!document.documentMode;
      isIE && H.classList.add('ie');
      // Edge
      window.isEdge = !!window.StyleMedia;
      isEdge && H.classList.add('edge');
      // Chrome 1+
      window.isChrome = !!window.chrome && !!window.chrome.webstore;
      isChrome && H.classList.add('chrome');
      // Blink
      window.isBlink = (isChrome || isOpera) && window.CSS;
      isBlink && H.classList.add('blink');
    })(document.documentElement);
  </script>
  <link href="assets/css/style.css" rel="stylesheet">
</head>

<body>
<svg  xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1">

  <symbol id="littleninja" width="828.861" height="850.313" viewBox="0 0 828.861 850.313" preserveAspectRatio="xMidYMid meet">
    <g transform="matrix(0.1,0,0,-0.1,-155.6,1231.8838)"><path d="m5300 12309.709c-760-56-1367-310-1795-750-357-366-563-835-593-1348l-7-115-115-94c-295-241-527-441-632-546-332-330-504-617-579-966-20-91-23-133-23-315 1-208 18-362 56-487l11-38 303 0 303 0-14 33c-47 112-77 296-76 467 2 347 124 602 441 921 115 116 397 369 411 369 3 0 23-53 44-117 100-313 236-540 460-772 224-231 483-401 816-535 331-132 649-201 1109-239l35-3-35-6c-19-4-764-39-1655-78-891-40-1621-72-1621-73-1-1-71-149-157-329l-155-328 50 0c27 0 860 38 1851 85 991 47 1818 84 1837 83 32-3 17-12-160-107-839-446-1701-1099-2677-2030l-163-155 0-510 0-511 151 160c225 238 679 687 891 882 589 540 1134 963 1615 1252 157 94 444 241 471 241 43 0 445-247 697-428 640-461 1282-1032 2118-1880l207-211 0 537 0 537-218 191c-1058 932-1952 1620-2523 1943-68 38-131 74-139 79-11 8-7 11 20 15 19 3 816 40 1770 82 954 41 1758 78 1786 81l51 5 195 425c119 258 190 424 182 424-7 0-100-15-206-34-654-116-1492-216-2153-256-215-13-1028-50-1075-49-22 0-7 6 43 15 643 116 1203 431 1564 879 375 466 506 1110 367 1805-64 319-215 643-413 884-68 83-232 245-311 309-446 357-1015 557-1730 607-165 11-474 11-630-1zm635-909c708-44 1251-246 1601-595 219-219 317-434 331-726 20-438-173-790-570-1037-281-176-643-287-1099-337-198-22-673-31-879-16-696 51-1186 229-1510 551-196 193-297 403-330 682-71 609 324 1090 1096 1337 372 119 875 171 1360 141z"/></g>
  </symbol>
  <use xlink:href="#littleninja" />
</svg>

  <div class="holygrail around-xs">
    <div class="col-xs-11 col-sm-10 wrapper">
      <input type="checkbox" id="menu-toggle">
      <aside class="main-menu">
        <label for="menu-toggle" class="menu-toggle">
          <span class="nav-item -magenta">Menu</span>
          <span class="nav-item -magenta">Hide</span>
        </label>
        <header class="header-left">
          <a href="/" class="logo">
            <svg>
              <use class="logo-littleninja" xlink:href="assets/img/stereokai.svg#littleninja"></use>
            </svg>
            <svg>
              <use class="logo-stereokai" xlink:href="assets/img/stereokai.svg#brand"></use>
            </svg>
          </a>
        </header>
        <nav>
          <ul class="nav-list">
            <li class="nav-item upper -green">Lorem.</li>
            <li class="nav-item -magenta">Saepe.</li>
            <li class="nav-item -cyan">Animi.</li>
            <li class="nav-item -orange">Debitis.</li>
            <li class="nav-item -yellow">Ipsa.</li>
            <li class="nav-item -violet">Ipsa.</li>
          </ul>
        </nav>
      </aside>
      <section class="content">
        <header class="header-right">
          <a href="/" class="logo">
            <svg>
              <use class="logo-littleninja" xlink:href="assets/img/stereokai.svg#littleninja"></use>
            </svg>
            <svg>
              <use class="logo-stereokai" xlink:href="assets/img/stereokai.svg#brand"></use>
            </svg>
          </a>
        </header>
        <main class="box typeset show-gri">









            <!-- <h2 class="name-title"><a href="/">André Staltz</a></h2> -->
            <h1 class="post-title">Unidirectional User Interface Architectures</h1>
            <h3 class="post-date">22 Aug 2015</h3>

<p>This post is a non-exhaustive quick overview of the so-called “unidirectional data flow” architectures. Not meant to be taken as a beginner tutorial, but rather as an overview of their differences and peculiarities. At the end, I’ll introduce a new architecture which deviates significantly from the others. This post assumes client-side Web UI frameworks only.</p>

<h2 id="terminology" class="hr"><span class="hr">TERMINOLOGY</span></h2>

<p>It would be confusing to talk about these architectures without a common terminology, so let’s assume the following.</p>

<blockquote>
  <p><strong>User events</strong> are events coming from input devices directly manipulated by the user. Examples: mouse clicks, scrolls, keyboard presses, touches on a touchscreen, etc.</p>
</blockquote>

<p>Architectures might use the term “View” with drastically different connotations. Instead, we use “rendering” to refer to the common understanding of “View”:</p>

<blockquote>
  <p><strong>User interface rendering</strong> is the graphical output on the screen, commonly expressed as HTML or some comparable high-level declarative code such as JSX.</p>
</blockquote>

<blockquote>
  <p>A <strong>User interface (UI) program</strong> is any program which takes user events as input and outputs rendering, as an ongoing process rather than a one-time transformation.</p>
</blockquote>

<p>The DOM and other layers such as frameworks and libraries are assumed to exist between the user and the architecture.</p>

<p><strong>Ownership of inter-module arrow matters.</strong> <code class="highlighter-rouge">A--&gt;  B</code> is different than <code class="highlighter-rouge">A  --&gt;B</code>. The former is Passive programming, while the latter is Reactive programming. Read more <a href="http://cycle.js.org/observables.html#reactive-programming">here</a>.</p>

<blockquote>
  <p>A unidirectional architecture is said to be <strong>fractal</strong> if subcomponents are structured in the same way as the whole is.</p>
</blockquote>

<p>In fractal architectures, the whole can be naively packaged as a component to be used in some larger application.</p>

<p>In non-fractal architectures, the non-repeatable parts are said to be <strong>orchestrators</strong> over the parts that have hierarchical composition.</p>

<h2 id="flux" class="hr"><span class="hr">FLUX</span></h2>

<p>First compulsory mention goes to <a href="https://github.com/facebook/flux/">Flux</a>. It cannot be said to be the absolute pioneer, but at least in terms of popularity, it is the first unidirectional architecture for many people.</p>

<p><strong>Parts:</strong></p>

<ul>
  <li><strong>Stores</strong>: manage business data and state</li>
  <li><strong>View</strong>: a hierarchical composition of React components</li>
  <li><strong>Actions</strong>: events created from user events that triggered on the View</li>
  <li><strong>Dispatcher</strong>: an event bus for all actions</li>
</ul>

<p><a href="/img/flux-unidir-ui-arch.jpg"><img src="/img/flux-unidir-ui-arch.jpg" alt="Flux diagram"></a></p>

<p><strong>Peculiarities:</strong></p>

<p><strong>Dispatcher.</strong> Because this is an event bus, it’s a singleton. Many Flux variants remove the need for a dispatcher, and other unidirectional architectures don’t have an equivalent to the dispatcher.</p>

<p><strong>Only View has composable components.</strong> Hierarchical composition happens only among React components, not with Stores neither with Actions. A React component is a UI program, and is usually not written as a Flux architecture internally. Hence Flux is not fractal, where the orchestrators are the Dispatcher and the Stores.</p>

<p><strong>User event handlers are declared in the rendering.</strong> In other words, the <code class="highlighter-rouge">render()</code> function of React components handles both directions of interaction with the user: rendering and user event handlers (e.g. <code class="highlighter-rouge">onClick={this.clickHandler}</code>).</p>

<h2 id="redux" class="hr"><span class="hr">REDUX</span></h2>

<p><a href="http://rackt.github.io/redux/">Redux</a> is a variation of Flux where the singleton Dispatcher was adapted to become a singleton Store. The Store is not implemented from scratch, instead, it is created by giving a reducer function to a store factory.</p>

<p><strong>Parts:</strong></p>

<ul>
  <li><strong>Singleton Store</strong>: manages state and has a <code class="highlighter-rouge">dispatch(action)</code> function</li>
  <li><strong>Provider</strong>: a subscriber to the Store which interfaces with some “View” framework like React or Angular</li>
  <li><strong>Actions</strong>: events created from user events that are created under the Provider</li>
  <li><strong>Reducers</strong>: pure functions from previous state and an action to new state</li>
</ul>

<p><a href="/img/redux-unidir-ui-arch.jpg"><img src="/img/redux-unidir-ui-arch.jpg" alt="Redux diagram"></a></p>

<p><strong>Peculiarities:</strong></p>

<p><strong>Factories for stores.</strong> A Store is created using the <code class="highlighter-rouge">createStore()</code> factory function, taking a composition of reducer functions as argument. There is also a meta-factory <code class="highlighter-rouge">applyMiddleware()</code> function which takes middleware functions as arguments. Middlewares are mechanisms of overriding the <code class="highlighter-rouge">dispatch()</code> function of a store with additional chained functionality.</p>

<p><strong>Providers.</strong> Redux is unopinionated with regards to the “View” framework used to make the UI program. It can be used with React or Angular or others. In the context of this architecture, “View” is a UI program. Like Flux, Redux is not (by design) fractal and the Store is an orchestrator.</p>

<p><strong>User event handlers may or may not be declared in the rendering.</strong> It depends on the Provider at hand.</p>

<h2 id="best" class="hr"><span class="hr">BEST</span></h2>

<p>The <a href="https://blog.famous.org/introducing-the-famous-framework/">Famous Framework</a> introduced Behavior-Event-State-Tree (BEST) as a variant of MVC, where the Controller is split into two unidirectional elements: Behavior and Event.</p>

<p><strong>Parts:</strong></p>

<ul>
  <li><strong>State</strong>: JSON-like declaration of initial state</li>
  <li><strong>Tree</strong>: a declarative hierarchical composition of components</li>
  <li><strong>Event</strong>: event listeners (on tree) that mutate state</li>
  <li><strong>Behavior</strong>: dynamic properties (of tree) dependent on the state</li>
</ul>

<p><a href="/img/best-unidir-ui-arch.jpg"><img src="/img/best-unidir-ui-arch.jpg" alt="BEST diagram"></a></p>

<p><strong>Peculiarities:</strong></p>

<p><strong>Multi-paradigm.</strong> State and Tree are fully declarative. Event is imperative. Behavior is functional. Some parts are reactive, other parts are passive (e.g. Behavior reacts to State, and Tree is passive to the Behavior).</p>

<p><strong>Behavior.</strong> Not seen in any other architecture in this post, the Behavior separates UI rendering (Tree) from its dynamic properties. These are allegedly different concerns: Tree is comparable to HTML, Behavior is comparable to CSS.</p>

<p><strong>User event handlers are declared separately from rendering.</strong> BEST is one of the few unidirectional architectures that do not attach user event handlers in the rendering. User event handlers belong to Event, not to Tree.</p>

<p>In the context of this architecture, “View” is a Tree, and a “Component” is a Behavior-Event-Tree-State tuple. Components are UI programs. BEST is a fractal architecture.</p>

<h2 id="elm" class="hr"><span class="hr">MODEL-VIEW-UPDATE</span></h2>

<p>Also known as “<a href="https://github.com/evancz/elm-architecture-tutorial/">The Elm Architecture</a>”, Model-View-Update shares similarities to Redux, mainly because the latter is inspired by this architecture. This is a purely functional architecture because its host language is <a href="http://elm-lang.org/">Elm</a>, a functional programming language for the Web.</p>

<p><strong>Parts:</strong></p>

<ul>
  <li><strong>Model</strong>: a type defining the structure of state data</li>
  <li><strong>View</strong>: a pure function transforming state into rendering</li>
  <li><strong>Actions</strong>: a type defining user events sent through mailboxes</li>
  <li><strong>Update</strong>: a pure function from previous state and an action to new state</li>
</ul>

<p><a href="/img/mvu-unidir-ui-arch.jpg"><img src="/img/mvu-unidir-ui-arch.jpg" alt="Model-View-Update diagram"></a></p>

<p><strong>Peculiarities:</strong></p>

<p><strong>Hierarchical composition everywhere.</strong> The previous architectures had hierarchical composition only in their “View”, however in the MVU architecture such composition is also found in Model and Update. Even Actions may contain nested Actions.</p>

<p><strong>Components are exported as pieces.</strong> Because of the hierarchical composition everywhere, a “component” in the Elm Architecture is a tuple of: a Model type, an initial Model instance, a View function, an Action type, and an Update function. There cannot be components which deviate from this structure throughout the whole architecture. Each component is a UI program, and this architecture is fractal.</p>

<h2 id="elm" class="hr"><span class="hr">MODEL-VIEW-INTENT</span></h2>

<p>Introduced as a fully reactive unidirectional architecture based on <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a> Observables, Model-View-Intent is the primary architectural pattern in the framework <a href="http://cycle.js.org">Cycle.js</a>. The <em>Observable</em> event stream is a primitive used everywhere, and functions over Observables are pieces of the architecture.</p>

<p><strong>Parts:</strong></p>

<ul>
  <li><strong>Intent</strong>: function from Observable of user events to Observable of “actions”</li>
  <li><strong>Model</strong>: function from Observable of actions to Observable of state</li>
  <li><strong>View</strong>: function from Observable of state to Observable of rendering</li>
  <li><strong>Custom element</strong>: subsection of the rendering which is in itself a UI program. May be implemented as MVI, or as a Web Component. Is optional to use in a View.</li>
</ul>

<p><a href="/img/mvi-unidir-ui-arch.jpg"><img src="/img/mvi-unidir-ui-arch.jpg" alt="Model-View-Intent diagram"></a></p>

<p><strong>Peculiarities:</strong></p>

<p><strong>Heavily based on Observables.</strong> The outcome of each part of the architecture is expressed as an Observable event stream. Because of this, it is hard or impossible to express any “data flow” or “change” without using Observables.</p>

<p><strong>Intent.</strong> Roughly comparable to <em>Event</em> in BEST, user event handlers are declared in the Intent, separately from rendering. Unlike BEST, Intent produces Observable streams of actions, which are like those in Flux, Redux, and Elm. Unlike Flux and others, though, actions in MVI are not directly sent to a Dispatcher or a Store. They are simply available for the Model to listen.</p>

<p><strong>Fully reactive.</strong> The user’s rendering reacts to the View’s output, which reacts to the Model’s output, which reacts to the Intent’s output (actions), which reacts to user events.</p>

<p>A MVI tuple is a UI program. This architecture is fractal if and only if all custom elements are implemented with MVI.</p>

<h2 id="nested-dialogues" class="hr"><span class="hr">NESTED DIALOGUES</span></h2>

<p>This blog post introduces <em>Nested Dialogues</em> as a new unidirectional architecture meant for Cycle.js and any other approach based solely on Observables. It is an evolution of the Model-View-Intent architecture.</p>

<p>Start from the fact that a Model-View-Intent sequence can be functionally composed as a single function, a “Dialogue”:</p>

<p><a href="/img/dialogue-mvi-unidir-ui-arch.jpg"><img src="/img/dialogue-mvi-unidir-ui-arch.jpg" alt="A Dialogue function equivalent to Model-View-Intent"></a></p>

<p>As the diagram suggests, a <strong>Dialogue</strong> is a function taking an Observable of user events as input (the input of Intent) and outputting an Observable of renderings (the output of View). Therefore a Dialogue is a UI program.</p>

<p>We generalize the definition of a Dialogue to allow other targets beyond the user, with an input Observable and an output Observable for each target. For example, if a Dialogue interfaces with a user and a server over HTTP, the Dialogue would take two Observables as input: Observable of user events and Observable of HTTP responses. Then, it would output two Observables as output: Observable of renderings and Observable of HTTP requests. This is the concept of <a href="http://cycle.js.org/drivers.html">Drivers</a> in Cycle.js.</p>

<p>This is how Model-View-Intent restructured as a Dialogue looks like:</p>

<p><a href="/img/single-dialogue-unidir-ui-arch.jpg"><img src="/img/single-dialogue-unidir-ui-arch.jpg" alt="A Dialogue function as a UI program"></a></p>

<p>To reuse a Dialogue function as a subcomponent UI program in a larger program is a matter of nesting a Dialogue inside another one:</p>

<p><a href="/img/nested-dialogues-unidir-ui-arch.jpg"><img src="/img/nested-dialogues-unidir-ui-arch.jpg" alt="Nested Dialogues"></a></p>

<p>The wiring of Observables between layers of Dialogues is a data flow graph. It is not necessarily an acyclic graph. There are cases such as dynamic lists of subcomponents where a cycle is needed in the data flow graph. Examples of such are beyond the scope of this blog post.</p>

<p>Nested Dialogues is in fact a meta-architecture: it has no convention for the internal structure of a component, allowing us to embed any of the aforementioned architectures into a Nested Dialogue component. The only convention regards the interface of a Dialogue’s extremes: input must be a (collection of) Observable(s), output also must be a (collection of) Observable(s). If a UI program structured as Flux or Model-View-Update or others can have its output and inputs expressed as Observables, then that UI program can be embedded into a Nested Dialogues program as a Dialogue function.</p>

<p>This architecture is therefore fractal (with regards to the Dialogue interface only) and general.</p>

<p>See this <a href="https://github.com/cyclejs/todomvc-cycle">TodoMVC implementation</a> and <a href="https://github.com/cyclejs/cycle-examples/tree/master/bmi-nested">this small app</a> as examples of Nested Dialogues with Cycle.js.</p>

<h2 id="elm" class="hr"><span class="hr">MY BIASED CONCLUSION</span></h2>

<p>While the generality and elegance of Nested Dialogues can be theoretically used to embed other architectures as subcomponents, I am mainly interested in this architecture for structuring Cycle.js applications. I have been searching for a UI architecture which feels <strong>natural</strong> and <strong>flexible</strong>, while at the same providing <strong>structure</strong>.</p>

<p>I believe Nested Dialogues is <em>natural</em> because it directly represents what any typical UI program does: an ongoing process (Observables are ongoing processes) that takes user events as input (the input Observable), and produces rendering as output (the output Observable).</p>

<p>It should be a <em>flexible</em> architecture as well, because as we saw, the internal structure of a Dialogue can be freely implemented with any pattern. This is in contrast to Model-View-Update which has a rigid structure as convention. Fractal architectures seem more reusable than non-fractals, so I’m glad Nested Dialogues has this property too.</p>

<p>However, some common <em>structure</em> can be helpful to guide development. While I believe the internal structure of a Dialogue could be Flux, I think Model-View-Intent fits the Observable input/output interface naturally. So while I want to be free to not implement a Dialogue as MVI, I acknowledge most of the times I will structure it as MVI.</p>

<p>I don’t want to be pretentious to say this is the best user interface architecture, because I have just discovered it and still need to use it in the wild to see its pros and cons. Nested Dialogues is just my strongest bet at the moment.</p>

<hr>

<p><a href="https://news.ycombinator.com/item?id=10115314">Comments in Hacker News</a>.</p>


          <p>
          If you liked this article, consider sharing <a href="https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fstaltz.com%2Funidirectional-user-interface-architectures.html&amp;text=Unidirectional%20User%20Interface%20Architectures&amp;tw_p=tweetbutton&amp;url=http%3A%2F%2Fstaltz.com%2Funidirectional-user-interface-architectures.html&amp;via=andrestaltz" rel="nofollow" target="_blank" title="tweeting">(tweeting)<span style="text-decoration: underline"></span></a> it to your followers.
          </p>


<!--           <article>
            <h1>Type on Screen</h1>
            <p>by ARAL BALKAN</p>
            <p>One of the iconic representations of the digital age is an image of the ubiquitous digital screen, stereotypically represented as a grid of brightly-lit pixels.</p>
            <p>This, like many of our other traditional perceptions of digital and interactive experiences, are either changing or being replaced altogether as we enter the post-PC era. New devices have such high resolution displays that individual pixels become imperceptibly small. Other devices, like the Amazon Kindle, eschew pixels altogether — opting to use electronic ink.<br></p>
            <p>These new devices are radically transforming what is possible in digital visual design and this has radical implications for digital typography.&nbsp;</p>
            <p>The death of the pixel leaves you with a flowing, magazine-quality canvas to design for. A canvas where curves are curves, not ugly pixel approximations of curves. A canvas that begins to blur the line between what we consider to be real and what we consider to be virtual.</p>
            <p>It wasn't too long ago that there was one set of rules for use of type on print and use of type on screen. Now that we have screens that are essentially print quality, we have to reevaluate these conventions.</p>
            <p> Web sites are transforming from boring fields of Arial to embrace the gamut of typographical possibilities offered by web fonts. Web fonts, combined with the style and layout options presented by the creative use of CSS and JavaScript offer a new world of typographic opportunity on the web.&nbsp;</p><h2>Emotional Typography</h2>
            <p>Web fonts allow for a wider palette of typefaces which can provide far more quirkiness and personality.</p>
            <p>The challenge is to help people understand this. The classics such as Arial, Helvetica, Verdana or Tahoma are engrained as fonts you will always expect to see; readers aren't used to seeing type choices beyond these usual suspects.</p>
            <p>The majority of screen graphics are done with JPGs that don't scale from the regular screens to retina screens. Now if you have these new type choices as web fonts, you have a scalable version of this which you can use, providing endless possibilities.</p><h2>Technical Advantages</h2>
            <p>Think of this as adapting your tone of voice to the type of person or situation you are in. If you were being given a medical diagnosis the tone would not be fun or light-hearted. In contrast talking colloquially to a close friend could be the opposite of this.</p>
            <p>Web fonts allow you to have this kind of razor-sharp efficiency and elegance in design whilst at the same time avoiding the need for adding additional page graphics, which in turn add load time, decrease workflow performance and risk breaking across screen dimensions and device situations.</p>
          </article> -->
        </main>
      </section>
    </div>
  </div>
  <!-- <script src="assets/js/scripts.js"></script> -->
</body>

</html>
